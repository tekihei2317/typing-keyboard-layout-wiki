# ローマ字テーブルの変換アルゴリズムを理解する

Google日本語入力のローマ字テーブルカスタマイズ機能を使うと、色々なかな配列を実装することができます。

tomoemonさんがmozcの挙動を観察して模倣したものがあるので、これを使って理解することにします。

[tomoemon/google_input: Implementation of Google IME like Romaji Input Algorithm](https://github.com/tomoemon/google_input)

なぜ理解したいのかというと、配列を試すプレイグラウドと配列を分析するツールを作っているからです。

プレイグラウンドについてはAIに丸投げして作ってもらいました。しかし、分析するためにはかな→ストロークに逆変換するアルゴリズムが必要で、分からないままだと実装できないというか今後の方針を判断できないので~~諦めて~~勉強することにしました。

## ローマ字テーブルについて

難しいのは「次の入力」があるからなのですが、そもそも次の入力って何なのという解説は以下の記事に詳しいです。

[Google IMEで携帯入力 - 「次の入力」の秘密 - - tomoemonの日記](https://tomoemon.hateblo.jp/entry/20101024/p1)

ケータイ入力の設定ファイル。1を押すとあ→い→う→...となるもの。

```text
1<tab><tab>あ
あ1<tab><tab>い
い1<tab><tab>う
う1<tab><tab>え
え1<tab><tab>お
お1<tab><tab>あ
```

「まだ変換が確定していない部分」を持っている。次の入力は、ルールが合致したときにそこに文字列を追加する機能。

出力は、確定済みにする機能。

「まだ変換が確定していない部分」については、次の入力を使わなくても出てくる。例えばローマ字入力だと、「ak」と打った時は「あk」とkの部分は未確定。

ローマ字入力のローマ字テーブルには「n→ん」というルールがあるけど、「na→な」や「nn→ん」というルールもあるので、「n」と打ったときはまだ未確定。

「nk」と打ったときに「んk」に変換される。kは未確定。

ここら辺の挙動を考えて前実装してみたけど、結構不具合があったのでより正確な実装を読んでみる。

## コードを読む

結構難しそうなのでゆっくり読んでいく。

- FilterRule ローマ字テーブルの1行を表す
- FilterRuletable ローマ字テーブルを表す
- FilterResult 文字を入力したときの結果を表すデータ

FilterResultが何を表しているか見てみる。

確定、仮確定、次にマッチする可能性がある。

次にマッチする可能性があるは、例えばnを打ったときの「na→な」「nn→ん」とかのことかな。バッファに対する前方一致。

tmp_fixedは、nと打ったときの「n→ん」のルールだろうか。

fixedは、nkと打ったときの「n→ん」だろうか。ちょっとここはコード見ないと分からない。

```python
class FilterResult:
    """ GoogleInput.input の返り値

    Attributes:
        input (str): 入力した文字列
        next_input (str): ルールにマッチした場合、そのルールの「次の入力」
        tmp_fixed (FilterRule): 仮確定したルール。他にマッチするルールがなくなった際に確定する
        fixed (FilterRule): 確定したルール
        next_candidates (list(FilterRule)): input が入力されている状態で次にマッチする可能性があるルールのリスト
    """

    def __init__(self, input, next_input, tmp_fixed, fixed, next_candidates):
        self.input = input
        self.next_input = next_input
        self.tmp_fixed = tmp_fixed
        self.fixed = fixed
        self.next_candidates = next_candidates

    def __str__(self):
        t = self.tmp_fixed
        f = self.fixed
        return f"""{{
    input: {self.input},
    tmp: {{in: {t.input if t else "None"}, out: {t.output if t else "None"} }}
    fixed: {{in: {f.input if f else "None"}, out: {f.output if f else "None"} }}
    next_input: {self.next_input}
    num_of_next_candidates: {len(self.next_candidates)}
}}"""
```

fixedは確定した時の、入力した文字列と、出力する文字列の組み合わせ。

例えば月林檎だと

q		せ
せe	ぁ

なので、qeと打ったときは`せe`→`ぁ`が入っている。

tmpは、マッチしたけど、他にルールがあるので確定できないときに、マッチしたルールが入っている。

例えばローマ字入力でnと打ったときの`n`→`ん`。

なんとなく分かってきたので、コードを読んでいく。~~読み始めるの遅くね？~~

```python
def input(self, char):
    """ 1文字を入力として受け付け、その変換結果を返す

    Args:
        char (str): 入力文字
    Returns:
        FilterResult: 入力文字に対応する変換結果を途中の状態も含めて返す
    """
    if not self.next_candidates:
        candidates = self.rule_table.rules
    else:
        candidates = self.next_candidates

    next_candidates = []
    input = self.input_buffer + char
    tmp_fixed = self.tmp_fixed
    for rule in candidates:
        if rule.input.startswith(input):
            if rule.input == input:
                tmp_fixed = rule
            else:
                next_candidates.append(rule)
```

next_candidatesを編集していると思われる部分。

今までの入力に対する候補がある場合はそれ、なければルール全体を対象に、現在のバッファに前方一致するものだけをフィルタリングしている。

その中で、入力に一致するものがあればtmp_fixedに入れている。これは他に候補がなかったら確定するためのものっぽい。

```python
def input(self, char):
  （略）
  if not next_candidates:
      """ 次以降の入力にマッチするルールの候補がない """
      if tmp_fixed:
          """ これまでの入力で確定したルールがある """
          if len(tmp_fixed.input) == len(input):
              """ 今回の入力でちょうどルールにマッチした場合
              マッチしたルールの「次の入力」が引き回される
              """
              self.input_buffer = tmp_fixed.next_input
          else:
              """ 前回のルールにマッチしており、今回そのルールから外れる入力があった場合
              マッチしたルールの「次の入力」と今回の入力が引き回される
              """
              self.input_buffer = tmp_fixed.next_input + char
          self.tmp_fixed = None
          return FilterResult(input, self.input_buffer, None, tmp_fixed, next_candidates)
      else:
          """ これまでの入力で確定したルールがない（ミス入力） """
          self.input_buffer = ""
          self.tmp_fixed = None
          return FilterResult(input, "", None, None, next_candidates)
```

まずは候補がない場合。

tmp_fixedがない場合。

`FilterResult(input, next_input, tmp_fixed, fixed, next_candidates)`の順番。

tmp_fixedがある場合。input_bufferの更新が2通りあって、ここが重要に見える。まず、最終的にはtmp_fixedを確定させている。

それからはなんだろう。分からなくなってきた...。

候補がある場合は、まだ確定することができない。tmp_fixedを設定している。

```python
def input(self, char):
  （略）
  else:
      """ 次以降の入力にマッチするルールの候補がある """
      self.input_buffer = input
      self.tmp_fixed = tmp_fixed
      return FilterResult(input, "", tmp_fixed, None, next_candidates)
```

## まとめ

むず。とりあえずどういう情報を持っているかを把握して、手を動かして考えてみることにしよう。

まず、現在の入力に対して前方一致する候補の一覧を持っている。`next_candidates`

完全一致する場合は、それも持っている。`tmp_fixed`

候補がない場合は確定させられる。

で、今回の入力で確定した場合と、前回（それ以前？）に確定した場合で、次の入力に関する違いがある。

ここが一番重要な部分だと思われる。前回の入力で一致した場合、っていうのは、「nk」と打った時の「n→ん」のことかな。
